
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
//напиши функцию filter, которая принимает функцию-предикат и массив.
// Возвращает она массив значений, для которых предикат вернет true.
//
//    var input = [1, 2, 3, 4, 5, 6];
//function isEven(x) { return x % 2 == 0; } // проверяет на четность
//console.log(filter(input, isEven)); // [2, 4, 6]
//Функция не должна изменять исходный массив:
//
//    console.log(input); // [1, 2, 3, 4, 5, 6]
function filter(f) {
    return function() {
        var result = f.apply(this, arguments); // виклик f
        return result;
    };
}
var even = function(x) { // функція проверяет на четность
    return x % 2 == 0;
};
var odd = filter(even);
var arr = [2,4,6,8,10].every(odd);
if (arr == true) {
    console.log(arr);
} else {
    console.log("заповніть масив парними числами");
}





//Напиши функцию неглубокого копирования объектов и массивов.
//
//    По умолчанию, как ты наверно, знаешь, при копировании объектов или массивов
//(которые являются объекты) мы копируем лишь ссылку на тот же самый объект:
//
//    var a = [1, 2, 3];
//var b = a; // b указывает на тот же массив
//b.push(4);
//console.log(a); // [1, 2, 3, 4]
//Функция неглубокого копирования должна создавать новый массив/объект, и
//копировать в него элементы из старого. При этом сами элементы копируются по ссылке:
//
//    var a = { x: 1, y: 2, z: [1, 2, 3] };
//var b = shallowCopy(a); // b — это отдельный объект
//b.x = 10;
//console.log(a.x); // 1
//
//// Но a.z и b.z указывают на один и тот же массив:
//b.z.push(4);
//console.log(a.z); // [1, 2, 3, 4]


</script>
</body>
</html>

